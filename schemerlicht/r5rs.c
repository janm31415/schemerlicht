#include "r5rs.h"
#include "parser.h"
#include "context.h"
#include "token.h"
#include "compiler.h"
#include "vm.h"
#include "preprocess.h"

void schemerlicht_compile_r5rs(schemerlicht_context* ctxt)
  {
  char* script = "(define caar(lambda(x) (car(car x))))\n"
    "(define cadr(lambda(x) (car(cdr x))))\n"
    "(define cdar(lambda(x) (cdr(car x))))\n"
    "(define cddr(lambda(x) (cdr(cdr x))))\n"
    "(define caaar(lambda(x) (car(car(car x)))))\n"
    "(define caadr(lambda(x) (car(car(cdr x)))))\n"
    "(define cadar(lambda(x) (car(cdr(car x)))))\n"
    "(define caddr(lambda(x) (car(cdr(cdr x)))))\n"
    "(define cdaar(lambda(x) (cdr(car(car x)))))\n"
    "(define cdadr(lambda(x) (cdr(car(cdr x)))))\n"
    "(define cddar(lambda(x) (cdr(cdr(car x)))))\n"
    "(define cdddr(lambda(x) (cdr(cdr(cdr x)))))\n"
    "(define caaaar(lambda(x) (car(car(car(car x))))))\n"
    "(define caaadr(lambda(x) (car(car(car(cdr x))))))\n"
    "(define caadar(lambda(x) (car(car(cdr(car x))))))\n"
    "(define caaddr(lambda(x) (car(car(cdr(cdr x))))))\n"
    "(define cadaar(lambda(x) (car(cdr(car(car x))))))\n"
    "(define cadadr(lambda(x) (car(cdr(car(cdr x))))))\n"
    "(define caddar(lambda(x) (car(cdr(cdr(car x))))))\n"
    "(define cadddr(lambda(x) (car(cdr(cdr(cdr x))))))\n"
    "(define cdaaar(lambda(x) (cdr(car(car(car x))))))\n"
    "(define cdaadr(lambda(x) (cdr(car(car(cdr x))))))\n"
    "(define cdadar(lambda(x) (cdr(car(cdr(car x))))))\n"
    "(define cdaddr(lambda(x) (cdr(car(cdr(cdr x))))))\n"
    "(define cddaar(lambda(x) (cdr(cdr(car(car x))))))\n"
    "(define cddadr(lambda(x) (cdr(cdr(car(cdr x))))))\n"
    "(define cdddar(lambda(x) (cdr(cdr(cdr(car x))))))\n"
    "(define cddddr(lambda(x) (cdr(cdr(cdr(cdr x))))))\n"
    "(define map(lambda(proc lst1 . lsts)\n"
    "   (if (null? lsts)\n"
    "      (let loop([lst lst1])\n"
    "        (if (null? lst)\n"
    "          '()\n"
    "          (cons (proc (car lst)) (loop(cdr lst)))\n"
    "          ))\n"
    "      (let loop ([lsts(cons lst1 lsts)])\n"
    "        (let ([hds(let loop2([lsts lsts])\n"
    "          (if (null? lsts)\n"
    "            '()\n"
    "            (let([x(car lsts)])\n"
    "              (and (not (null? x))\n"
    "                (let([r(loop2(cdr lsts))])\n"
    "                  (and r(cons(car x) r))\n"
    "                  )))))])\n"
    "          (if hds"
    "          (cons(apply proc hds)\n"
    "            (loop(let loop3([lsts lsts])\n"
    "              (if (null? lsts)\n"
    "                '()\n"
    "                (cons(cdar lsts) (loop3(cdr lsts)))\n"
    "                ))))\n"
    "            '()\n"
    "            ))))))\n"
    " (define for-each(lambda(proc lst1 . lsts)\n"
    "   (if (null? lsts)\n"
    "     (let loop([lst lst1])\n"
    "       (unless(null? lst)\n"
    "         (proc(car lst))\n"
    "         (loop(cdr lst))))\n"
    "     (let loop([lsts(cons lst1 lsts)])\n"
    "       (let([hds(let loop2([lsts lsts])\n"
    "         (if (null? lsts)\n"
    "           '()\n"
    "           (let([x(car lsts)])\n"
    "             (and (not (null? x))\n"
    "               (let([r(loop2(cdr lsts))])\n"
    "                 (and r(cons(car x) r)))))))])\n"
    "         (when hds(apply proc hds)\n"
    "           (loop(let loop3([lsts lsts])\n"
    "             (if (null? lsts)\n"
    "               '()\n"
    "               (cons(cdar lsts) (loop3(cdr lsts)))\n"
    "               )))))))))\n"
    "  (define force(lambda(p)\n"
    "    (if (promise? p)\n"
    "      ((slot-ref p 0))\n"
    "      p\n"
    "      )))\n"
    "  (define make-promise(lambda(proc)\n"
    "    (let([result-ready? #f]\n"
    "      [result #f])\n"
    "      (%make-promise(lambda()\n"
    "        (if result-ready?\n"
    "          result\n"
    "          (let([x(proc)])\n"
    "            (if result-ready?\n"
    "              result\n"
    "              (begin(set! result-ready? #t)\n"
    "                (set! result x)\n"
    "                result\n"
    "              )))))))))\n"
    " (define standard-input-port(make-port #t \"stdin\" 0 (make-string 4096) 4096 4096))\n"
    " (define standard-output-port(make-port #f \"stdout\" 1 (make-string 4096) 0 4096))\n"
    " (define standard-error-port(make-port #f \"stderr\" 2 (make-string 4096) 0 4096))\n"
    " (define current-output-port (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       standard-output-port\n"
    "       (set! standard-output-port(car args))\n"
    "       ))))\n"
    " (define current-input-port (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       standard-input-port\n"
    "       (set! standard-input-port (car args))\n"
    "       ))))\n"
    " (define current-error-port (lambda ( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       standard-error-port\n"
    "       (set! standard-error-port(car args))\n"
    "       ))))\n"
    " (define read-char (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%read-char standard-input-port)\n"
    "       (%read-char (car args))\n"
    "       ))))\n"
    " (define peek-char (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%peek-char standard-input-port)\n"
    "       (%peek-char (car args))\n"
    "       ))))\n"
    " (define write-char (lambda(c . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%write-char c standard-output-port)\n"
    "       (%write-char c (car args))\n"
    "       ))))\n"
    " (define flush-output-port (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%flush-output-port standard-output-port)\n"
    "       (%flush-output-port (car args))\n"
    "       ))))\n"
    " (define char-ready? (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%char-ready? standard-input-port)\n"
    "       (%char-ready? (car args))\n"
    "       ))))\n"
    " (define newline(lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (begin(%write-char #\\newline standard-output-port) (%flush-output-port standard-output-port))\n"
    "       (begin(%write-char #\\newline(car args)) (%flush-output-port (car args)))\n"
    "       ))))\n"
    " (define write (lambda(c . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (begin (%write c standard-output-port) (%flush-output-port standard-output-port))\n"
    "       (begin (%write c (car args)) (%flush-output-port (car args)))\n"
    "       ))))\n"
    " (define display (lambda(c . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (begin (%display c standard-output-port) (%flush-output-port standard-output-port))\n"
    "       (begin (%display c (car args)) (%flush-output-port (car args)))\n"
    "       ))))\n"
    " (define read (lambda( . args)\n"
    "   (let([l(length args)])\n"
    "     (if (eq? l 0)\n"
    "       (%read standard-input-port)\n"
    "       (%read (car args))\n"
    "       ))))\n"
    " (define values #f)\n"
    " (define call-with-values #f)\n"
    " (let((magic(cons 'multiple 'values)))\n"
    "   (define magic?\n"
    "     (lambda(x)\n"
    "       (and (pair? x) (eq? (car x) magic))))\n"
    "   (set! values\n"
    "   (lambda args\n"
    "   (if (and (not (null? args)) (null? (cdr args)))\n"
    "     (car args)\n"
    "     (cons magic args))))\n"
    "   (set! call-with-values\n"
    "   (lambda(producer consumer)\n"
    "     (let((x(producer)))\n"
    "       (if (magic? x)\n"
    "         (apply consumer(cdr x))\n"
    "         (consumer x))))))\n"
    "(define error (lambda (reason . args)  ; conform srfi-23\n"
    "         (display \"Error: \")\n"
    "         (display reason)\n"
    "         (for-each (lambda (arg) \n"
    "                     (display \" \")\n"
    "                    (write arg))\n"
    "          args)\n"
    "         (%write-char #\\newline standard-output-port) (%flush-output-port standard-output-port)\n"
    "         (halt #undefined)\n"
    "))\n"
    "(define (curry func . args)\n"
    "    (lambda x (apply func (append args x))))\n";


  schemerlicht_vector tokens = schemerlicht_script2tokens(ctxt, script);
  schemerlicht_program prog = make_program(ctxt, &tokens);
  schemerlicht_preprocess_internal_libs(ctxt, &prog);
  schemerlicht_vector r5rs = schemerlicht_compile_program(ctxt, &prog);
  schemerlicht_run_program(ctxt, &r5rs);
  destroy_tokens_vector(ctxt, &tokens);
  schemerlicht_program_destroy(ctxt, &prog);
  schemerlicht_compiled_program_register(ctxt, &r5rs);
  }
